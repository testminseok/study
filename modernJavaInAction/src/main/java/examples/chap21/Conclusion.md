# 자바 8의 기능 리뷰
자바 8에 추가된 대부분의 새로운 기능은 자바에서 함수형 프로그래밍을 쉽게 적용할 수 있게 도와준다.
자바 8에서 이렇게 큰 변화가 생긴 이유는 커다란 두가지 추세 때문이다.
- 한 가지 추세는 멀티코어 프로세서의 파워를 충분히 활용해야 한다는 것이다. 무어의 법칙에 따라 실리콘 기술이 발전하면서
  개별 CPU 코어의 속도가 빨라지고 있다. 즉, 코드를 병렬로 실행해야 더 빠르게 코드를 실행할 수 있다.
- 데이터 소스를 이용해서 주어진 조건과 일치하는 모든 데이터를 추출하고. 결과에 어떤 연산을 적용하는 등 선엉형으로 데이터를 처리하는 방식,
  즉 간결하게 데이터 컬렉션을 다루는 추세다. 간결하게 데이터 컬렉션을 처리하려면 불변값을 생산할 수 있는 불변 객체와 불변 컬렉션이 필요하다.

## 동작 파라미터 화(람다와 메소드 참조)
filter 메소드를 만들 때 기존의 자바로도 이런 기능을 구현할 수 있지만, 보통 상당히 복작합 코드를 구현해야 하며 따라서 유지보수하는 것도 쉽지 않다.
- apple -> apple.getWeight() > 150 같은 람다 코드를 전달할 수 있다.
- Apple::isHeavy 같은 기존 메소드의 메소드 참조를 전달할 수 있다.

메소드로 전달되는 값은 Function<T, R>, Predicate<T>, BiFunction<T, U, R> 등의 형식을 가지며 메소드를 수신한 코드에서는
apply, test 등의 메소드로 코드를 실행할 수 있다. 

## 스트림
자바의 컬렉션 클래스, 반복자, for-each 구문은 오랫동안 사용된 기능이다. 자바 8 설계자는 기존의 컬렉션에 람다를 활용한 filter, map 등의 메소드를
추가해서 데이터베이스 질의 같은 기능을 제공하는 비교적 쉬운 방법을 선택할 수 있었지만 그러지 않고 완전히 새로운 스트림 API 를 만들었다.

컬렉션에 어떤 문제가 있으며 스트림과 비슷한 점과 다른점은 무엇일까? 예를 들어 큰 컬렉션에 세 가지 연산을 적용한다고 가정하자
우선 컬렉션의 필드를 더할 수 있는 객체를 매핑하고, 어떤 조건은 만족하는 합계를 필터링한 다음에, 결과를 정렬해야 한다.
따라서 컬렉션을 각각 세 번 탐색해야한다. 스트림 API 는 이들 연산을 파이프라인이라는 게으른 형식의 연산으로 구성한다.
그리고 한 번의 탐색으로 파이프라인의 모든 연산을 수행한다. 큰 데이터 집합일수록 스트림의 데이터 처리 방식이 효율적이며,
또한 메모리 캐시 등의 관점에서도 커다란 데이터 집합일수록 탐색 횟수를 최소하하는 것이 아주 중요하다.

또한 멀티코어 CPU 를 활용해서 병렬로 요소를 처리하는 기능도 매우 중요한 점이다. 스트림의 parallel 메소드는 스트림을 병렬로 처리하도록 지정하는 역활을 한다.
상태 변화는 병렬성의 가장 큰 걸림돌이다. 따라서 함수형 개념은 map, filter 등의 연산을 활용하는 스트림의 병렬처리의 핵심으로 자리 잡았다.

## CompletableFuture class
자바 5부터 Future 인터페이스를 제공했는데 이 Future 를 이용하면 여러 작업이 동시에 실행될 수 있도록 다른 스레드나 코어로 작업을 할당할 수 있다.
즉, 멀티코어를 잘 활용할 수 있다. 다른 작업을 생성한 시존 작업에서 결과가 필요할 떄는 get 메소드를 호출해서 생성된 Future 가 완료될 때까지 기다릴 수 있다.

자바 8부터는 이러한 Future 를 구현하는 CompletableFuture 클래스가 제공된다. 
CompletableFuture 는 'CompletableFuture 와 Future 스트림과 컬렉션의 관계와 같다'랴는 좌우명을 주장한다.
- 스트림에서는 파이프라인 연산을 구성할 수 있으므로 map, filter 등으로 파라미터화를 제공한다. 
  따라서 반복자를 사용했을 때 생기는 불필요한 코드를 피할 수 있다.
- 마찬가지로 CompletableFuture 는 Future 와 관련된 공통 디자인 패턴을 함수형 프로그래밍으로 간결하게 표현할 수 있도록
  thenCompose, thenCombine, allOf 등을 제공한다. 따라서 명령형에서 발생하는 불필요한 코드를 피할 수 있다.

## Optional class
자바 8 라이브러리는 T 형식의 값을 반환하거나 아니면 값이 없을을 의미하는 Optional.empty 라는 정적 메소드를 반환할 수 있는 Optional<T> 클래스를 제공한다.
Optional<T> 는 프로그램을 쉽게 이해하고 문서화하는 데 큰 도움을 준다. 즉 Optional<T> 는 에러가 잘 발생할 수 있는 계산을 수행하면서
값이 없을 때 에러를 발생시킬 수 있는 null 대신 정해진 데이터 형식을 제공할 수 있다.  일관적으로 Optional<T> 를 사용한다면 NullPointException 이 발생하지 않을 것이다.
'없는 값의 형식을 다른 값으로 표현하는 기능이 도대체 프로그램 구현에 무슨 도움을 주는 걸까?'라고 생각할 수 있지만, 자세히 살펴보면 Optional<T> 클래스는
map, filter, ifPresent 를 제공한다. 스트림 클래스가 제공하는 것과 비슷한 동작으로 계산을 연결할 떄 함수형으로 map, filter, ifPresent 등을 사용할 수 있으며,
값이 없는 상황을 사용자 코드에서 확인하는 것이 아니라 라이브러리에서 확인할 수 있다. 값을 내부적으로 검사하는 것과 외부적으로 검사하는 것은 사용자 코드에서 
시스템 라이브러리가 내부 반복을 하느냐 아니면 외부 반복을 하느냐와 같은 의미를 갖는다. 
자바 9에서는 Optional API 에 stream(), or(), ifPresentOrElse() 등의 새로운 메소드가 추가됐다.

## Flow API 
자바 9에서는 리액티브 스트림과 리액티브 당김 기반 역압력 프로토콜(소비자가 빠른 생산자를 대응하지 못해 발생하는 문제를 방지하는 기법) 을 표준화 했다.
Flow API 는 호환성을 높일 수 있도록 라이브러리가 구현할 수 있는 네 개의 인터페이스 Publisher, Subscriber, Subscription, Processor 를 포함한다.

## Default method
자바 8에서는 인터페이스에 default 메소드를 추가할 수 있게 되면서 라이브러리 설계자가 기존 인터페이스를 수정하지 않고도 새로운 메소드를 추가할 수 있게 되었다.
자바 9에서는 인터페이스에 private 메소드를 추가할 수 있게 되었다. 이 기능은 인터페이스를 구현하는 클래스에서 private 메소드를 사용할 수 있게 해준다.
특히 인터페이스에 새로운 기능을 추가했을 대 기존의 모든 사용자가 이 새로 추가된 기능을 구현하지 않을 수 있다는 점에서 유용하다.

## 구체화된 제네릭
자바 5에서 제네릭을 소개했을 떄 네네릭이 기존 JVM 과 호환성을 유지해야했다. 결과적으로 ArrayList<String> 이나 ArrayList<Integer> 모두 런타임 표현이 같게 되었다.
이를 제네릭 다형성의 삭제 모델 이라고 한다. 이 때문에 약간의 런타임 비용을 지불하게 되었으며 제네릭 형식의 파라미터로 객체만 사용할 수 있게 되었다.
(기본형을 제네릭으로 사용하지 못하는 이유) 예를 들어 자바가 ArrayList<int> 를 지원한다고 가정할때 int 42 같은 기본형을 포함하는 ArrayList 객체를
힙 메모리 영역에 할당할 수 있겠지만 ArrayList 컨테이너가 String 같은 객체값을 포함하는 것인지 아니면 42 같은 기본형 int 값을 포함하는것인지 알 수 없게 된다.

가비지 컬렉션(GC) 는 런타임에 ArrayList 의 콘텐츠 형식 정보를 확일할 수 없으므로 ArrayList 의 13이라는 요소가 Integer 참조인지(GC가 '사용 중'으로 표시) 
아니면 int 값인지(GC 수행 불가) 알 수 없게 된다.

## 값 형식
컴파일러가 Integer 와 int 를 같은 값으로 취급할 순 없을까 ?
컴파일러가 Integer 와 int 를 JVM 에 맞게 같은 값으로 최적화를 해준다면 문제를 해결할 수 있다.

클래스는 참조 형식이므로 어떤 동작을 수행하려면 객체를 생성해야 한다. 이때 생성된 클래스에 대응하는 기본형이 필요하다.
하지만 자바와 JVM 은 이러한 기능을 지원하지 않는다. '컴파일러가 뭔가 해줄 수 있지 않을까'라고 기대해볼 수 있지만, 
탈출분석(escape analysis), 즉 언박싱 동작이 괜찮은지 결정하는 컴파일러 최적화 기법이 있지만 이는 자바 1.1 이후에 제공되는 객체에만 적용된다.
기본형에서는 비트를 비교해서 같음을 판단하지만 객체에서는 참조로 같음을 판단한다.

